import networkx as nx
import random


def generate_erdos_renyi_graph(n, p):
    """
    Genera un grafo Erdős-Rényi (G(n, p)) conectado.
    Parámetros:
    - n (int): Número de nodos.
    - p (float): Probabilidad de creación de una arista entre cualquier par de nodos.
    Retorna:
    - G (networkx.Graph): Un grafo Erdős-Rényi conectado.
    """
    G = nx.erdos_renyi_graph(n, p, seed=30)
    if not nx.is_connected(G):
        # Extrae el componente conectado más grande si el grafo no está conectado
        print(f"Erdős-Rényi graph with p={p} is not connected. Extracting the largest connected component.")
        G = G.subgraph(max(nx.connected_components(G), key=len)).copy()
    return G


#generate Albert-Barabasi graph
def generate_albert_barabasi_graph(n, m):
    """
    Genera un grafo de Preferencia (Scale-Free) conectado usando el modelo de Barabási-Albert.

    Parámetros:
    - n (int): Número de nodos.
    - m (int): Número de aristas a adjuntar de un nuevo nodo a nodos existentes.

    Retorna:
    - G (networkx.Graph): Un grafo de Preferencia conectado.
    """
    G = nx.barabasi_albert_graph(n, m, seed=30)
    if not nx.is_connected(G):
        # Extrae el componente conectado más grande si el grafo no está conectado
        print(f"Scale-Free graph with m={m} is not connected. Extracting the largest connected component.")
        G = G.subgraph(max(nx.connected_components(G), key=len)).copy()
    return G


# Stochastic Block Model Generator
def generate_sbm(sizes_sbm, p_intra, p_inter):
    # sizes_sbm: array - length of this array determines number of blocks,
    #                    each entry indicates number of nodes per block
    # p_intra: constant - probability of connection between nodes inside same block (in [0,1])
    # p_inter: constant - probability of connection between nodes in different blocks (in [0,1])

    # Define the probability matrix
    probs_sbm = [[p_intra if i == j else p_inter for j in range(len(sizes_sbm))] for i in range(len(sizes_sbm))]
    # Generate SBM graph
    G_sbm = nx.stochastic_block_model(sizes_sbm, probs_sbm, seed=42)
    # Check if the graph is connected
    while nx.is_connected(G_sbm) == False:
        print("Original graph was not connected. Generating a new one")
        G_sbm = nx.stochastic_block_model(sizes_sbm, probs_sbm, seed=42)
    print(f"SBM Graph: {G_sbm.number_of_nodes()} nodes, {G_sbm.number_of_edges()} edges")

    return G_sbm


# Configuration Model
def generate_configuration_model(degree_sequence):
    """
    Generate a random graph using the Configuration Model.

    :param degree_sequence: List of integers representing the degree of each node.
    :return: A NetworkX graph generated by the Configuration Model.
    """
    # Check if the degree sequence is valid
    if sum(degree_sequence) % 2 != 0:
        raise ValueError("The sum of the degree sequence must be even.")

    # Generate the graph using NetworkX's configuration model
    G = nx.configuration_model(degree_sequence)

    # Convert the graph to a simple graph (no parallel edges or self-loops)
    G = nx.Graph(G)  # Remove parallel edges
    G.remove_edges_from(nx.selfloop_edges(G))  # Remove self-loops

    return G


# Hierarchical Configuration Model
def generate_hierarchical_configuration_model(in_degree_sequence, ext_degree_sequence, community_sizes):
    """
    Generate a random graph using the Hierarchical Configuration Model
    :param in_degree_sequence: List of integers representing the inner degree of each vertex (connections with vertices
                                inside the same community)
    :param ext_degree_sequence: List of integers representing the outer degree of each vertex (connections with vertices
                                outside the community)
    :param community_sizes: List of integers representing the size of each community (length of this list determines
                            number of communities)
    :return: A NetworkX graph generated by the Hierarchical Configuration Model
    """
    n = len(in_degree_sequence)

    # check the introduced data passes first inspection
    if n != len(ext_degree_sequence) or n != sum(community_sizes):
        raise ValueError("The length of the inside degrees sequence, the outside degrees sequence and the total "
                         "number of vertices specified by the community_sizes list must be equal")

    # create graph
    G = nx.empty_graph(0, nx.MultiGraph)

    # create intra community edges, prepare inter community edges
    offset = 0
    outer_half_edges = []
    for h, size_h in enumerate(community_sizes):
        # get inter community half-edges, store them in list of lists
        ext_degrees_h = ext_degree_sequence[offset:offset + size_h]
        outer_half_edges.append([i + offset for i, count in enumerate(ext_degrees_h) for _ in range(count)])

        # get intra community edges
        in_degrees_h = in_degree_sequence[offset:offset + size_h]

        # check data is consistent
        if sum(in_degrees_h) % 2 != 0:
            raise ValueError("The sum of the inner degree sequence for each community must be even")

        # get intra community half_edges
        half_edges_h = [i + offset for i, count in enumerate(in_degrees_h) for _ in range(count)]
        half_h = len(half_edges_h) // 2
        random.shuffle(half_edges_h)
        first_half_h, second_half_h = half_edges_h[:half_h], half_edges_h[half_h:]
        new_internal_edges = list(zip(first_half_h, second_half_h))
        G.add_edges_from(new_internal_edges)
        offset += size_h

    # create inter community edges
    ext_edges = []
    while any(outer_half_edges):
        # Select community with the highest number of outer half-edges remaining
        non_empty_sublists = [lst for lst in outer_half_edges if lst]
        community = max(non_empty_sublists, key=len, default=[])

        #select one half edge from the community with the highest number of outer half-edges remaining
        half_edge = random.choice(community)
        community.remove(half_edge)
        new_ext_edge = ()
        new_ext_edge += (half_edge,)

        #Select a random community and a random half-edge from that community
        # (excluding the one we sampled the first half-edge from)
        selected_community = random.choice([lst for lst in non_empty_sublists if lst != community])
        selected_half_edge = random.choice(selected_community)
        selected_community.remove(selected_half_edge)
        new_ext_edge += (selected_half_edge,)

        # Randomly select two communities
        #non_empty_sublists = [lst for lst in outer_half_edges if lst]
        #selected_communities = random.sample(non_empty_sublists, 2)

        # Randomly select an outer half edge of each community, create and edge with them
        #new_ext_edge = ()
        #for community in selected_communities:
        #   selected_half_edge = random.choice(community)
        #    community.remove(selected_half_edge)
        #    new_ext_edge += (selected_half_edge,)

        ext_edges.append(new_ext_edge)

    G.add_edges_from(ext_edges)

    return G
